{"name":"Validator.py","tagline":"A library for validating that dictionary values meet certain sets of parameters. Much like form validators, but for dicts.","body":"validator.py [![Build Status](https://travis-ci.org/mansam/validator.py.png?branch=master)](https://travis-ci.org/mansam/validator.py)\r\n============\r\n\r\nThis documentation is also available at [ReadTheDocs](http://validatorpy.readthedocs.org/en/latest/index.html).\r\n\r\nAbout\r\n-----\r\n\r\n``validator.py`` is a tool for ensuring that data conforms to certain sets of rules, called validations. A validation is essentially a schema for a dictionary, containing a list of rules for each key/value pair in the dictionary you want to validate. This is intended to fill a similar use case to form validations in WTForms or Rails, but for general sources of data, not just web forms. To get right on with it, here's a quick example of what this is for and how it works:\r\n\r\n```python\r\nfrom validator import Required, Not, Truthy, Blank, Range, Equals, In, validate\r\n\r\n# let's say that my dictionary needs to meet the following rules...\r\nrules = {\r\n    \"foo\": [Required, Equals(123)], # foo must be exactly equal to 123\r\n    \"bar\": [Required, Truthy()],    # bar must be equivalent to True\r\n    \"baz\": [In([\"spam\", \"eggs\", \"bacon\"])], # baz must be one of these options\r\n    \"qux\": [Not(Range(1, 100))] # qux must not be a number between 1 and 100 inclusive\r\n}\r\n\r\n# then this following dict would pass:\r\npasses = {\r\n    \"foo\": 123,\r\n    \"bar\": True, # or a non-empty string, or a non-zero int, etc...\r\n    \"baz\": \"spam\",\r\n    \"qux\": 101\r\n}\r\n>>> validate(rules, passes)\r\n(True, {}) \r\n\r\n# but this one would fail\r\nfails = {\r\n    \"foo\": 321,\r\n    \"bar\": False, # or 0, or [], or an empty string, etc...\r\n    \"baz\": \"barf\",\r\n    \"qux\": 99\r\n}\r\n>>> validate(rules, fails)\r\n(False, {\r\n 'foo': [\"must be equal to 123\"],\r\n 'bar': ['must be True-equivalent value'],\r\n 'baz': [\"must be one of ['spam', 'eggs', 'bacon']\"],\r\n 'qux': ['must not fall between 1 and 100']\r\n})\r\n```\r\n\r\nNotice that the validation that passed just returned True and an empty ``dict``, but the one that failed returned a tuple with False and a ``dict`` with a list of related error messages for each key that failed. This lets you easily see exactly what failed in a human readable way.\r\n\r\nInstallation\r\n------------\r\nStable releases can be installed via ``pip install validator.py``. Alternatively, you can get the latest sources or a release tarball from http://github.com/mansam/validator.py.\r\n\r\n``validator.py`` is written with Python 2.7, but is tested with 2.6 and PyPy. It should also work with 2.5 and 3.x, though the tests currently won't run on 3.x.\r\n\r\nGetting Started with Validations\r\n--------------------------------\r\n\r\nA validation (the set of rules used to test a dict) can be flat --consisting of just a single level of tests-- or it can contain additional conditionally nested validations. \r\n\r\nTo create a validation, you insert a list of callables into a validation dictionary for each key/value pair in the dictionary you want to validate. When you call ``validate`` with the validation and your dictionary, each of those callables will be called with the respective value in your dictionary as their argument. If the callable returns ``True``, then you're good to go. For example:\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": \"bar\"\r\n}\r\nvalidation = {\r\n    \"foo\": [lambda x: x == \"bar\"] \r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nWhen ``validate`` got called in the example, the value of ``dictionary[\"foo\"]`` got passed to lambda in the list, and since ``dictionary[\"foo\"] == \"bar\"``, everything is good and the dictionary is considered valid!\r\n\r\nWriting your own callables is helpful in some cases, but ``validator.py`` helpfully provides a wide range of validations that should cover most of the common use cases.\r\n\r\n\r\nAvailable Validators\r\n--------------------\r\n\r\nThe ``Equals`` validator\r\n------------------------\r\n\r\nThe ``Equals`` validator just checks that the dictionary value matches the parameter to ``Equals``. We use it to rewrite our previous example more succinctly:\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": \"bar\"\r\n}\r\nvalidation = {\r\n    \"foo\": [Equals(\"bar\")]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIn the event that it fails, it explains so clearly:\r\n\r\n```python\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must be equal to 'baz'\"]})\r\n```\r\n\r\nThe ``Required`` validator\r\n--------------------------\r\n\r\nBy default, a key is considered optional. A key that's in the validation but isn't in the dictionary under test just gets silently skipped. To make sure that a key is present, use the ``Required`` validator. Adding the ``Required`` validator to the list of rules for a key ensures that the key must be present in the dictionary. Unlike most of the other validators that ``validator.py`` provides, ``Required`` shouldn't be written with parentheses.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": \"bar\"\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, Equals(\"bar\")]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIn the event that a key is missing:\r\n\r\n```python\r\nfailure = {}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"is missing\"]})\r\n```\r\n\r\nThe ``Truthy`` validator\r\n--------------------------\r\n\r\nThe ``Truthy`` validator checks that the dictionary value is something that Python treats as true. True, non-0 integers, non-empty lists, and strings all fall into this category.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": 1\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, Truthy()]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIn the event that a key is not True-equivalent:\r\n\r\n```python\r\nfailure = {\"foo\": 0}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must be True-equivalent value\"]})\r\n```\r\n\r\nThe ``Range`` validator\r\n--------------------------\r\n\r\nThe ``Range`` validator checks that the dictionary value falls inclusively between the start and end values passed to it.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": 10\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, Range(1, 11)]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIf the value falls outside the specified range:\r\n\r\n```python\r\nfailure = {\"foo\": 12}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must fall between 1 and 11\"]})\r\n```\r\n\r\nYou can also have Range exclude its endpoints by changing the `inclusive` keyword argument to false.\r\n\r\n```python    \r\nRange(1, 11, inclusive=False)\r\n```\r\n\r\nThe ``Pattern`` validator\r\n--------------------------\r\n\r\nThe ``Pattern`` validator checks that the dictionary value matches the regex pattern that was passed to it.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": \"30%\"\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, Pattern(\"\\d\\d\\%\")]\r\n}\r\n```\r\n\r\n```python\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIf the value doesn't match the regex:\r\n\r\n```python\r\nfailure = {\"foo\": \"99.0\"}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must match regex pattern \\d\\d\\%\"]})\r\n```\r\n\r\nThe ``In`` validator\r\n--------------------------\r\n\r\nThe ``In`` validator checks that the dictionary value is a member of a collection passed to it.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": \"spam\"\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, In([\"spam\", \"eggs\", \"bacon\"])]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIf the value doesn't belong to the collection:\r\n\r\n```python\r\nfailure = {\"foo\": \"beans\"}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must be one of ['spam', 'eggs', 'bacon']\"]})\r\n```\r\n\r\nThe ``Not`` validator\r\n--------------------------\r\n\r\nThe ``Not`` validator negates a validator that is passed to it and checks the dictionary value against that negated validator.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": \"beans\"\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, Not(In([\"spam\", \"eggs\", \"bacon\"]))]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIf the value doesn't pass the Not'd validator (meaning it would have passed the validator without the Not), then Not provides a helpfully negated version of the validator's error message:\r\n\r\n```python\r\nfailure = {\"foo\": \"spam\"}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must not be one of ['spam', 'eggs', 'bacon']\"]})\r\n```\r\n\r\nThe ``InstanceOf`` validator\r\n----------------------------\r\n\r\nThe ``InstanceOf`` validator checks that the dictionary value is an instance of the base class passed to InstanceOf, or an instance of one of its subclasses.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": u\"i'm_a_unicode_string\"\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, InstanceOf(basestring)]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIf the value isn't an instance of the base class or one of its subclasses:\r\n\r\n```python\r\nfailure = {\"foo\": object}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must be an instance of basestring or its subclasses\"]})\r\n```\r\n\r\nThe ``SubclassOf`` validator\r\n----------------------------\r\n\r\nThe ``SubclassOf`` validator checks that the dictionary value is inherits from the base class passed to it. To be clear, this means that the dictionary value is expected to be a class, not an instance of a class.\r\n\r\n```python\r\ndictionary = {\r\n    \"foo\": unicode\r\n}\r\nvalidation = {\r\n    \"foo\": [Required, InstanceOf(basestring)]\r\n}\r\n\r\n>>> validate(validation, dictionary)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nIf the value isn't a subclass of base class or one of its subclasses (e.g. if it's an instance of that class or a subclass of something else):\r\n\r\n```python\r\nfailure = {\"foo\": \"bar\"}\r\n>>> validate(validation, failure)\r\n(False, {\"foo\": [\"must be a subclass of basestring\"]})\r\n```\r\n\r\nConditional Validations\r\n-----------------------\r\n\r\nIn some cases you might want to apply some rules only if other validations pass. You can do that with the ``If(validator, Then(validation))`` construct that ``validator.py`` provides. For example, you might want to ensure that ``pet['name']`` is a cat's name, but only if ``pet['type'] == 'cat'``. To do this, you'd use the ``If`` validator on the key that serves as the condition for the other set of the rules.\r\n\r\n```python\r\npet = {\r\n    \"name\": \"whiskers\",\r\n    \"type\": \"cat\"\r\n}\r\ncat_name_rules = {\r\n    \"name\": [In([\"whiskers\", \"fuzzy\", \"tiger\"])]\r\n}\r\ndog_name_rules = {\r\n    \"name\": [In([\"spot\", \"ace\", \"bandit\"])]\r\n}\r\nvalidation = {\r\n    \"type\": [\r\n        If(Equals(\"cat\"), Then(cat_name_rules)),\r\n        If(Equals(\"dog\"), Then(dog_name_rules))\r\n    ]\r\n}\r\n```\r\n\r\n```python\r\n>>> validate(validation, pet)\r\n(True, {})\r\n# Success!\r\n```\r\n\r\nA failed conditional validation will give you appropriately nested error messages so you know exactly where things went wrong.\r\n\r\n```python\r\npet = {\"type\":\"cat\", \"name\": \"lily\"}\r\n>>> validate(validation, pet)\r\n(False, {'type': [{'name': [\"must be one of ['whiskers', 'fuzzy', 'tiger']\"]}]})\r\n```\r\n\r\nThis is very powerful, but you'll need to take care that you don't create conflicting validations or cyclic validations-- ``validator.py`` won't be able to help you catch cycles.\r\n\r\nMore Information\r\n-----------------------\r\n\r\nFor more information, please visit http://github.com/mansam/validator.py or contact me at mansam@csh.rit.edu. You can also send me a message on freenode if you have any questions.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}